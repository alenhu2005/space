<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>胡哥哥地球運動演示系統 </title>
    <style>
        :root { --bg: #050508; --panel: #121216; --accent: #00e5ff; --gold: #ffd700; --text: #eee; }
        body {
            margin: 0; padding: 0;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            user-select: none;
        }

        /* --- Header --- */
        header {
            height: 45px;
            padding: 0 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(20,20,25,0.9);
            border-bottom: 1px solid #333;
        }
        h2 { margin: 0; font-size: 1rem; color: #fff; letter-spacing: 1px; }
        .stats { font-family: monospace; font-size: 0.85rem; color: #888; display: flex; gap: 15px; }
        .stats span { color: var(--gold); font-weight: bold; }
        .stats .highlight { color: var(--accent); }

        /* --- Main Layout --- */
        .viewport-container {
            flex-grow: 1;
            display: flex;
            position: relative;
            background: #000;
            overflow: hidden;
        }
        
        .canvas-wrapper {
            flex: 1;
            position: relative;
            border-right: 1px solid #333;
            background: radial-gradient(circle at bottom, #1b2735 0%, #090a0f 100%);
        }
        .canvas-wrapper:last-child { border-right: none; }
        
        canvas { display: block; width: 100%; height: 100%; outline: none; }

        /* --- Overlays --- */
        .view-label {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 4px 10px; border-radius: 4px;
            font-size: 0.8rem; color: var(--accent);
            border-left: 3px solid var(--accent);
            pointer-events: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }

        .cam-controls {
            position: absolute; top: 10px; right: 10px;
            display: flex; gap: 5px;
        }
        .btn-cam {
            background: rgba(255,255,255,0.1); border: 1px solid #444;
            color: #ccc; font-size: 0.7rem; padding: 4px 8px;
            cursor: pointer; border-radius: 3px; transition: 0.2s;
        }
        .btn-cam:hover { background: var(--accent); color: #000; border-color: var(--accent); }

        .legend {
            position: absolute; bottom: 10px; left: 10px;
            font-size: 0.75rem; color: #aaa;
            background: rgba(0,0,0,0.6); padding: 8px; border-radius: 4px;
            pointer-events: none;
        }
        .legend-row { display: flex; align-items: center; gap: 8px; margin-top: 3px; }
        .dot { width: 8px; height: 8px; border-radius: 50%; }
        .line { width: 15px; height: 2px; }

        /* --- Controls --- */
        .controls-area {
            height: 170px; 
            background: var(--panel);
            border-top: 1px solid #333;
            padding: 10px 20px;
            display: grid;
            grid-template-columns: 260px 1fr 200px;
            gap: 20px;
            box-sizing: border-box;
        }

        .lat-col { display: flex; flex-direction: column; justify-content: space-around; }
        .lat-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 4px; }
        .btn-lat {
            background: rgba(255,255,255,0.05); border: 1px solid transparent;
            color: #888; padding: 5px 0; font-size: 0.7rem;
            cursor: pointer; border-radius: 3px; transition: 0.2s;
        }
        .btn-lat:hover { background: rgba(255,255,255,0.15); color: #fff; }
        .btn-lat.active { background: rgba(0, 229, 255, 0.15); color: var(--accent); border-color: var(--accent); font-weight: bold; }
        .lbl-sm { font-size: 0.7rem; color: #666; margin-bottom: 2px; }

        .slider-col { display: flex; flex-direction: column; justify-content: center; gap: 10px; }
        .slider-row { display: flex; align-items: center; gap: 10px; font-size: 0.85rem; color: #ccc; }
        .lbl-w { width: 80px; text-align: right; font-size: 0.8rem; color: #999; }
        input[type=range] { flex: 1; height: 4px; background: #333; appearance: none; border-radius: 2px; cursor: pointer; }
        input[type=range]::-webkit-slider-thumb { appearance: none; width: 14px; height: 14px; background: var(--accent); border-radius: 50%; box-shadow: 0 0 5px var(--accent); }
        .val-disp { width: 65px; font-family: monospace; color: var(--gold); }

        .action-col { display: flex; flex-direction: column; justify-content: space-between; align-items: flex-end; padding: 5px 0; }
        .toggles { display: flex; flex-direction: column; gap: 4px; font-size: 0.8rem; color: #aaa; }
        .btn-play {
            width: 100%; padding: 8px; border: none; border-radius: 4px;
            background: linear-gradient(45deg, #ff9800, #ff5722);
            color: #fff; font-weight: bold; cursor: pointer;
            display: flex; align-items: center; justify-content: center; gap: 5px;
            transition: 0.3s;
        }
        .btn-play:hover { filter: brightness(1.1); }
        .btn-play.playing { background: linear-gradient(45deg, #e53935, #c62828); }

    </style>
</head>
<body>

    <header>
        <h2>胡哥哥太陽運動演示 <span style="font-size:0.7em; opacity:0.6">| Space & Ground View</span></h2>
        <div class="stats">
            <div>LAT <span id="txtLat">23.5°N</span></div>
            <div>TIME <span id="txtTime">12:00</span></div>
            <div>DAY <span id="txtDayLen" class="highlight">--h --m</span></div>
        </div>
    </header>

    <div class="viewport-container">
        <div class="canvas-wrapper">
            <div class="view-label">天球視角 (側面剖面圖)</div>
            <div class="cam-controls">
                <button class="btn-cam" onclick="cam1.reset(-90, 15)">側視 (標準)</button>
                <button class="btn-cam" onclick="cam1.reset(-90, 89)">俯視</button>
            </div>
            <canvas id="cvsObs"></canvas>
            <div class="legend">
                <div class="legend-row"><i class="line" style="background:var(--accent); height:3px;"></i> 地平圈</div>
                <div class="legend-row"><i class="line" style="background:cyan; height:1px;"></i> 天球赤道</div>
                <div class="legend-row"><i class="line" style="background:var(--gold)"></i> 太陽軌跡</div>
            </div>
        </div>

        <div class="canvas-wrapper">
            <div class="view-label">太空視角 (地球自轉 - 固定)</div>
            <canvas id="cvsSpace"></canvas>
            <div class="legend" style="right:10px; left:auto; bottom:10px; text-align:right;">
                <div class="legend-row" style="justify-content:flex-end;">亮面(白晝) <span style="color:#eee; font-weight:bold;">⮕ 右</span></div>
                <div class="legend-row" style="justify-content:flex-end;">暗面(夜晚) <span style="color:#555; font-weight:bold;">⬅ 左</span></div>
            </div>
        </div>
    </div>

    <div class="controls-area">
        <div class="lat-col">
            <div>
                <div class="lbl-sm">北半球</div>
                <div class="lat-grid">
                    <button class="btn-lat" onclick="setLat(90)">90</button>
                    <button class="btn-lat" onclick="setLat(66.5)">66.5</button>
                    <button class="btn-lat" onclick="setLat(45)">45</button>
                    <button class="btn-lat active" onclick="setLat(23.5)">23.5</button>
                    <button class="btn-lat" onclick="setLat(0)">0</button>
                </div>
            </div>
            <div>
                <div class="lbl-sm">南半球</div>
                <div class="lat-grid">
                    <button class="btn-lat" onclick="setLat(-23.5)">23.5</button>
                    <button class="btn-lat" onclick="setLat(-45)">45</button>
                    <button class="btn-lat" onclick="setLat(-66.5)">66.5</button>
                    <button class="btn-lat" onclick="setLat(-90)">90</button>
                </div>
            </div>
        </div>
        <div class="slider-col">
            <div class="slider-row">
                <div class="lbl-w">季節 (赤緯)</div>
                <input type="range" id="slSeason" min="-23.5" max="23.5" step="0.1" value="23.5">
                <div class="val-disp" id="txtSeason">夏至</div>
            </div>
            <div class="slider-row">
                <div class="lbl-w">時間 (0-24)</div>
                <input type="range" id="slTime" min="0" max="23.95" step="0.05" value="12">
                <div class="val-disp" id="txtTimeVal">12:00</div>
            </div>
            <div class="slider-row">
                <div class="lbl-w">觀測緯度</div>
                <input type="range" id="slLat" min="-90" max="90" step="0.5" value="23.5">
                <div class="val-disp" id="txtLatVal">23.5°</div>
            </div>
            <div class="slider-row">
                <div class="lbl-w">自動速度</div>
                <input type="range" id="slSpeed" min="0.1" max="5.0" step="0.1" value="1.0">
                <div class="val-disp" id="txtSpeed">1.0x</div>
            </div>
        </div>
        <div class="action-col">
            <div class="toggles">
                <label><input type="checkbox" id="chk3Path" checked> 二分二至軌跡</label>
                <label><input type="checkbox" id="chkEq" checked> 天球赤道</label>
                <label><input type="checkbox" id="chkAxis" checked> 地軸與連線</label>
            </div>
            <button id="btnPlay" class="btn-play" onclick="togglePlay()"><span>▶</span> 自動播放</button>
        </div>
    </div>

    <script>
        const PI = Math.PI;
        const rad = d => d * PI / 180;
        const deg = r => r * 180 / PI;
        const sin = Math.sin;
        const cos = Math.cos;

        const state = {
            lat: 23.5,
            dec: 23.5,
            hour: 12,
            speed: 1.0, 
            playing: false,
            lastTime: 0,
            opts: { show3: true, showEq: true, showAxis: true }
        };

        class Camera {
            constructor(az, el) { this.az = az; this.el = el; this.dragging = false; this.lx=0; this.ly=0; }
            reset(az, el) { this.az = az; this.el = el; render(); }
        }
        
        // 預設視角 -90 (面向西)
        // 右側 (+X) = 北方
        // 左側 (-X) = 南方
        // 前方 (+Z/Bottom) = 東方
        // 後方 (-Z/Top) = 西方
        const cam1 = new Camera(-90, 15);
        const cam2 = new Camera(0, 5); 

        const cvs1 = document.getElementById('cvsObs');
        const ctx1 = cvs1.getContext('2d');
        const cvs2 = document.getElementById('cvsSpace');
        const ctx2 = cvs2.getContext('2d');

        function project(ctx, x, y, z, w, h, cam, scale) {
            const cx = w/2, cy = h/2;
            const raz = rad(cam.az);
            const rel = rad(cam.el);
            
            let x1 = x * cos(raz) - z * sin(raz);
            let z1 = x * sin(raz) + z * cos(raz);
            let y1 = y;

            let y2 = y1 * cos(rel) - z1 * sin(rel);
            let z2 = y1 * sin(rel) + z1 * cos(rel);
            let x2 = x1;

            return {
                x: cx + x2 * scale,
                y: cy - y2 * scale, 
                z: z2
            };
        }

        const celToHor = (haDeg, decDeg, latDeg) => {
            const h = rad(haDeg);
            const d = rad(decDeg);
            const L = rad(latDeg);

            const y = sin(L)*sin(d) + cos(L)*cos(d)*cos(h);
            const x = cos(L)*sin(d) - sin(L)*cos(d)*cos(h);
            const z = -cos(d)*sin(h);

            return { x: x, y: y, z: z };
        };

        // --- 左側：天球視角 ---
        function renderObserver() {
            const w = cvs1.width, h = cvs1.height;
            const scale = Math.min(w, h) * 0.35;
            ctx1.clearRect(0, 0, w, h);
            const proj = (x,y,z) => project(ctx1, x, y, z, w, h, cam1, scale);

            // 地平圈
            ctx1.beginPath();
            for(let i=0; i<=360; i+=2) {
                let a = rad(i);
                let p = proj(cos(a), 0, sin(a));
                if(i===0) ctx1.moveTo(p.x, p.y); else ctx1.lineTo(p.x, p.y);
            }
            ctx1.closePath();
            ctx1.fillStyle = 'rgba(0, 229, 255, 0.15)';
            ctx1.fill();
            ctx1.strokeStyle = '#00e5ff'; 
            ctx1.lineWidth = 3; 
            ctx1.stroke();

            // 實心軸
            if(state.opts.showAxis) {
                ctx1.beginPath();
                // N-S Axis (X axis)
                let n = proj(1.1,0,0), s = proj(-1.1,0,0);
                ctx1.moveTo(n.x, n.y); ctx1.lineTo(s.x, s.y);
                // E-W Axis (Z axis)
                let e = proj(0,0,1.1), we = proj(0,0,-1.1);
                ctx1.moveTo(e.x, e.y); ctx1.lineTo(we.x, we.y);
                ctx1.setLineDash([]); 
                ctx1.strokeStyle = 'rgba(255,255,255,0.4)'; ctx1.lineWidth = 2; ctx1.stroke();
            }

            const txt = (t,x,y,z,c='#aaa') => {
                let p = proj(x,y,z);
                ctx1.fillStyle=c; ctx1.font='bold 14px Arial'; ctx1.textAlign='center'; ctx1.fillText(t,p.x,p.y);
            };
            
            // N (+X, 右), S (-X, 左), E (+Z, 前/下), W (-Z, 後/上)
            txt('北 (N)', 1.2, 0, 0, '#eee'); 
            txt('南 (S)', -1.2, 0, 0); 
            txt('東 (E)', 0, 0, 1.2); 
            txt('西 (W)', 0, 0, -1.2);

            const drawRing = (dec, color, w) => {
                let prev = null;
                // 畫完整的 360 度 (-180 到 180)
                for(let hDeg=-180; hDeg<=180; hDeg+=4) {
                    let pos = celToHor(hDeg, dec, state.lat);
                    let s = proj(pos.x, pos.y, pos.z);

                    if(prev) {
                        ctx1.beginPath(); 
                        ctx1.strokeStyle = color; 
                        ctx1.lineWidth = w;
                        
                        // --- 修正：地平線下變虛線 ---
                        if(pos.y < 0) {
                            ctx1.setLineDash([5, 5]); // 虛線
                            ctx1.globalAlpha = 0.4;   // 變暗
                        } else {
                            ctx1.setLineDash([]);     // 實線
                            ctx1.globalAlpha = 1.0;
                        }

                        ctx1.moveTo(prev.x, prev.y); ctx1.lineTo(s.x, s.y); 
                        ctx1.stroke();
                    }
                    prev = {x:s.x, y:s.y};
                }
                // 重置狀態
                ctx1.setLineDash([]);
                ctx1.globalAlpha = 1.0;
            };

            if(state.opts.showEq) drawRing(0, 'cyan', 1);
            if(state.opts.show3) {
                drawRing(23.5, '#ff4444', 1); 
                if(!state.opts.showEq) drawRing(0, '#ffff00', 1);
                drawRing(-23.5, '#4488ff', 1); 
            }
            drawRing(state.dec, '#ffd700', 3); 

            // Sun Position
            const ha = (state.hour - 12) * 15; 
            const sunPos = celToHor(ha, state.dec, state.lat);
            
            // 太陽本體與投影線
            const sunS = proj(sunPos.x, sunPos.y, sunPos.z);
            const gS = proj(sunPos.x, 0, sunPos.z);
            
            ctx1.beginPath(); ctx1.moveTo(sunS.x, sunS.y); ctx1.lineTo(gS.x, gS.y);
            ctx1.strokeStyle = 'rgba(255,255,0,0.3)'; ctx1.setLineDash([2,2]); ctx1.stroke(); ctx1.setLineDash([]);

            ctx1.beginPath(); ctx1.arc(sunS.x, sunS.y, 8, 0, PI*2);
            // 晚上太陽變暗一點
            ctx1.fillStyle = sunPos.y < 0 ? '#555' : '#ffd700'; 
            ctx1.fill(); 
            ctx1.strokeStyle = sunPos.y < 0 ? '#888' : '#fff'; 
            ctx1.stroke();

            if(state.opts.showAxis) {
                // 北極軸
                let p = celToHor(0, 90, state.lat); 
                let p1 = proj(p.x * 1.3, p.y * 1.3, p.z * 1.3);
                let p2 = proj(-p.x * 1.3, -p.y * 1.3, -p.z * 1.3);
                
                ctx1.beginPath(); ctx1.moveTo(p1.x, p1.y); ctx1.lineTo(p2.x, p2.y);
                ctx1.setLineDash([]); ctx1.strokeStyle='#fff'; ctx1.lineWidth=1; ctx1.stroke();
                
                ctx1.fillStyle='#fff'; ctx1.textAlign='left'; 
                ctx1.fillText("北極軸", p1.x + 5, p1.y);
            }
        }

        // --- 右側：太空視角 ---
        function renderSpace() {
            const w = cvs2.width, h = cvs2.height;
            const scale = Math.min(w, h) * 0.3;
            ctx2.clearRect(0, 0, w, h);
            const cx = w/2, cy = h/2;
            const projS = (x,y,z) => project(ctx2, x, y, z, w, h, cam2, scale);
            
            const tilt = rad(-state.dec);
            const applyTilt = (x, y, z) => {
                return {
                    x: x * cos(tilt) - y * sin(tilt),
                    y: x * sin(tilt) + y * cos(tilt),
                    z: z
                };
            };

            // 1. 地軸
            let axisLen = 1.4; 
            let np = applyTilt(0, axisLen, 0);
            let sp = applyTilt(0, -axisLen, 0);
            let npS = projS(np.x, np.y, np.z);
            let spS = projS(sp.x, sp.y, sp.z);

            ctx2.beginPath(); 
            ctx2.moveTo(npS.x, npS.y); ctx2.lineTo(spS.x, spS.y);
            ctx2.strokeStyle = '#cccccc'; ctx2.lineWidth = 4; ctx2.lineCap = 'round';
            ctx2.setLineDash([]); ctx2.stroke();

            // 2. 地球本體
            ctx2.beginPath(); ctx2.arc(cx, cy, scale, 0, PI*2);
            ctx2.fillStyle = 'rgba(20, 30, 50, 0.8)'; ctx2.fill();

            // 3. 經緯線 (自轉)
            let earthSpin = rad((state.hour - 12) * 15);
            const getSpherePos = (lonDeg, latDeg) => {
                let effLon = rad(lonDeg) - earthSpin; 
                let la = rad(latDeg);
                let x = cos(la) * cos(effLon);
                let y = sin(la);
                let z = cos(la) * sin(effLon);
                return applyTilt(x, y, z);
            };

            for(let lon=0; lon<360; lon+=30) {
                ctx2.beginPath();
                for(let lat=-90; lat<=90; lat+=5) {
                    let p = getSpherePos(lon, lat);
                    let s = projS(p.x, p.y, p.z);
                    if(lat===-90) ctx2.moveTo(s.x, s.y); else ctx2.lineTo(s.x, s.y);
                }
                if(lon===0) {
                    ctx2.strokeStyle = '#00ffff'; ctx2.lineWidth = 2;
                } else {
                    ctx2.strokeStyle = 'rgba(255,255,255,0.15)'; ctx2.lineWidth = 1;
                }
                ctx2.stroke();
            }
            
            for(let lat=-60; lat<=60; lat+=30) {
                ctx2.beginPath();
                for(let lon=0; lon<=360; lon+=5) {
                    let p = getSpherePos(lon, lat);
                    let s = projS(p.x, p.y, p.z);
                    if(lon===0) ctx2.moveTo(s.x, s.y); else ctx2.lineTo(s.x, s.y);
                }
                ctx2.strokeStyle = 'rgba(255,255,255,0.1)'; ctx2.lineWidth=1; ctx2.stroke();
            }

            // 4. 觀測者緯度圈
            ctx2.beginPath();
            for(let lon=0; lon<=360; lon+=5) {
                let la = rad(state.lat), lo = rad(lon);
                let p = applyTilt(cos(la)*cos(lo), sin(la), cos(la)*sin(lo));
                let s = projS(p.x, p.y, p.z);
                if(lon===0) ctx2.moveTo(s.x, s.y); else ctx2.lineTo(s.x, s.y);
            }
            ctx2.strokeStyle = '#0f0'; ctx2.lineWidth=1.5; ctx2.stroke();

            // 5. 光影
            ctx2.save();
            ctx2.beginPath(); ctx2.arc(cx, cy, scale, 0, PI*2); ctx2.clip();
            let shadowGrad = ctx2.createLinearGradient(cx - scale, 0, cx + scale, 0);
            shadowGrad.addColorStop(0.0, 'rgba(0,0,0,0.92)');
            shadowGrad.addColorStop(0.48, 'rgba(0,0,0,0.9)'); 
            shadowGrad.addColorStop(0.5, 'rgba(0,0,0,0.5)'); 
            shadowGrad.addColorStop(0.52, 'rgba(0,0,0,0)');
            shadowGrad.addColorStop(1.0, 'rgba(0,0,0,0)');
            ctx2.fillStyle = shadowGrad;
            ctx2.fillRect(0, 0, w, h);
            ctx2.restore();

            // 6. 標籤
            ctx2.font = '11px Arial'; 
            ctx2.textAlign = 'left';
            ctx2.textBaseline = 'middle';
            
            for(let lat of [-60, -30, 0, 30, 60]) {
                let pLabel = applyTilt(cos(rad(lat)), sin(rad(lat)), 0);
                let sLabel = projS(pLabel.x, pLabel.y, pLabel.z);
                
                let labelX = sLabel.x + 8; 
                let labelY = sLabel.y;

                let txt = Math.abs(lat) + "°";
                if(lat>0) txt+="N"; if(lat<0) txt+="S";
                
                let tw = ctx2.measureText(txt).width;
                ctx2.fillStyle = 'rgba(0,0,0,0.6)';
                ctx2.fillRect(labelX - 2, labelY - 6, tw + 4, 12);
                
                ctx2.fillStyle = '#ddd'; 
                ctx2.fillText(txt, labelX, labelY);
            }

            // 7. 觀測者
            let obsW = getSpherePos(0, state.lat); 
            let obsScr = projS(obsW.x, obsW.y, obsW.z);
            let isNight = obsW.x < -0.05;

            let stickEnd = getSpherePos(0, state.lat); 
            stickEnd.x *= 1.25; stickEnd.y *= 1.25; stickEnd.z *= 1.25; 
            let stickScr = projS(stickEnd.x, stickEnd.y, stickEnd.z);
            
            ctx2.beginPath(); ctx2.moveTo(obsScr.x, obsScr.y); ctx2.lineTo(stickScr.x, stickScr.y);
            ctx2.strokeStyle = 'magenta'; ctx2.lineWidth=2; ctx2.stroke();

            ctx2.beginPath(); ctx2.arc(obsScr.x, obsScr.y, 6, 0, PI*2);
            ctx2.fillStyle = isNight ? '#555' : '#f0f'; 
            ctx2.fill(); 
            ctx2.strokeStyle = isNight ? '#999' : '#fff'; 
            ctx2.lineWidth = 2; ctx2.stroke();

            if(isNight) {
                ctx2.fillStyle='#aaa'; ctx2.textAlign='center'; ctx2.fillText('Night', obsScr.x, obsScr.y - 10);
            }

            ctx2.font="bold 14px Arial"; ctx2.fillStyle="#fff"; ctx2.textAlign="center";
            ctx2.fillText("N", npS.x, npS.y - 10);
        }

        function render() {
            renderObserver();
            renderSpace();
        }

        function updateState() {
            state.lat = parseFloat(document.getElementById('slLat').value);
            state.dec = parseFloat(document.getElementById('slSeason').value);
            state.speed = parseFloat(document.getElementById('slSpeed').value); 
            
            if(!state.playing) state.hour = parseFloat(document.getElementById('slTime').value);
            
            state.opts.show3 = document.getElementById('chk3Path').checked;
            state.opts.showEq = document.getElementById('chkEq').checked;
            state.opts.showAxis = document.getElementById('chkAxis').checked;

            const latDir = state.lat>=0?'N':'S';
            document.getElementById('txtLat').innerText = Math.abs(state.lat).toFixed(1)+ "°" + latDir;
            document.getElementById('txtLatVal').innerText = Math.abs(state.lat).toFixed(1)+ "°";

            const h=Math.floor(state.hour), m=Math.floor((state.hour-h)*60);
            const tStr = `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;
            document.getElementById('txtTime').innerText = tStr;
            document.getElementById('txtTimeVal').innerText = tStr;

            document.getElementById('txtSpeed').innerText = state.speed.toFixed(1) + "x";

            let sTxt = state.dec.toFixed(1);
            if(Math.abs(state.dec-23.5)<1) sTxt="夏至";
            if(Math.abs(state.dec+23.5)<1) sTxt="冬至";
            if(Math.abs(state.dec)<1) sTxt="春秋分";
            document.getElementById('txtSeason').innerText = sTxt;

            let val = -Math.tan(rad(state.lat)) * Math.tan(rad(state.dec));
            let dayH = 0;
            if(val >= 1) dayH = 0; else if(val <= -1) dayH = 24; else dayH = deg(Math.acos(val)) * 2 / 15;
            let dh = Math.floor(dayH), dm = Math.floor((dayH - dh)*60);
            document.getElementById('txtDayLen').innerText = `${dh}h ${dm}m`;

            document.querySelectorAll('.btn-lat').forEach(b => b.classList.remove('active'));
            render();
        }

        function setLat(v) { document.getElementById('slLat').value = v; updateState(); }
        function togglePlay() {
            state.playing = !state.playing;
            document.getElementById('btnPlay').classList.toggle('playing');
            document.getElementById('btnPlay').innerHTML = state.playing ? "<span>⏸</span> 暫停" : "<span>▶</span> 自動播放";
            if(state.playing) { state.lastTime = performance.now(); requestAnimationFrame(loop); }
        }
        function loop(now) {
            if(!state.playing) return;
            const dt = now - state.lastTime;
            state.lastTime = now;
            
            state.hour += (dt / 200) * state.speed;
            
            if(state.hour >= 24) state.hour = 0;
            document.getElementById('slTime').value = state.hour;
            updateState();
            requestAnimationFrame(loop);
        }

        ['slLat', 'slSeason', 'slTime', 'slSpeed'].forEach(id => {
            document.getElementById(id).addEventListener('input', () => {
                if(state.playing && id==='slTime') togglePlay();
                updateState();
            });
        });
        ['chk3Path', 'chkEq', 'chkAxis'].forEach(id => document.getElementById(id).addEventListener('change', updateState));

        function bindDrag(cvs, cam) {
            const start = (e) => { cam.dragging = true; cam.lx = e.clientX||e.touches[0].clientX; cam.ly = e.clientY||e.touches[0].clientY; };
            const move = (e) => {
                if(!cam.dragging) return;
                let x = e.clientX||e.touches[0].clientX, y = e.clientY||e.touches[0].clientY;
                cam.az -= (x - cam.lx)*0.5; cam.el += (y - cam.ly)*0.5;
                if(cam.el>89)cam.el=89; if(cam.el<-89)cam.el=-89;
                cam.lx = x; cam.ly = y;
                render();
            };
            const end = () => cam.dragging = false;
            cvs.addEventListener('mousedown', start); window.addEventListener('mousemove', move); window.addEventListener('mouseup', end);
            cvs.addEventListener('touchstart', start, {passive:false}); window.addEventListener('touchmove', (e)=>{if(cam.dragging)e.preventDefault();move(e)}, {passive:false}); window.addEventListener('touchend', end);
        }
        bindDrag(cvs1, cam1); 

        window.addEventListener('resize', () => {
            const w1 = cvs1.parentElement.clientWidth, h1 = cvs1.parentElement.clientHeight;
            cvs1.width = w1; cvs1.height = h1;
            const w2 = cvs2.parentElement.clientWidth, h2 = cvs2.parentElement.clientHeight;
            cvs2.width = w2; cvs2.height = h2;
            render();
        });

        setTimeout(() => { window.dispatchEvent(new Event('resize')); updateState(); }, 50);

    </script>
</body>
</html>
